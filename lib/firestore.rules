rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }

    // Helper: fetch caller's user profile
    function callerProfile() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function isMember() {
      return isSignedIn() && callerProfile().data.isMember == true;
    }

    // Helper: limit updates to only specific keys
    function changedOnly(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }

    // Helper: field unchanged equality
    function unchanged(field) {
      return request.resource.data[field] == resource.data[field];
    }

    // Validate shape of an eventCustomQuestions document
    function validEventCustomQuestion(d) {
      return d.eventId is string && d.eventId.size() > 0
        && d.question is string && d.question.size() > 0
        && d.type in ['text','textarea','select','checkbox','radio']
        && d.required is bool
        && d.order is number
        && (
          // For option-based types, options must exist and be a list
          (d.type in ['select','checkbox','radio'] && ('options' in d) && d.options is list)
          // For free-text types, options must be absent or an empty list
          || (d.type in ['text','textarea'] && (!('options' in d) || (d.options is list && d.options.size() == 0)))
        );
    }

    // USERS (member profiles)
    match /users/{uid} {
      // Users may read their own profile; admins may read all; optionally open some fields publicly later.
      allow read: if isAdmin() || (isSignedIn() && request.auth.uid == uid);

      // Create own document at first sign-in or profile completion
      allow create: if isSignedIn() && request.auth.uid == uid
        // Limit client-writable fields; prevent role escalation
        && request.resource.data.keys().hasOnly([
          'displayName','email','photoURL','isMember','studentStatus','campus','university','expectedGraduationYear','linkedin','github','website','bio','name','gender','program','heardOfUs','newsletter','lookingForJob','privacyAcceptedAt','marketingOptIn','analyticsOptIn','partnerContactOptIn','createdAt','updatedAt','unsubscribedFromEmails','eventHistory'
        ]);

      // Update own doc but cannot alter privileged fields except allowed ones
      allow update: if isSignedIn() && request.auth.uid == uid
        && request.resource.data.keys().hasOnly([
          'displayName','email','photoURL','isMember','studentStatus','campus','university','expectedGraduationYear','linkedin','github','website','bio','name','gender','program','heardOfUs','newsletter','lookingForJob','privacyAcceptedAt','marketingOptIn','analyticsOptIn','partnerContactOptIn','updatedAt','unsubscribedFromEmails','eventHistory'
        ]);

      // Admin full control
      allow create, update, delete: if isAdmin();
    }

    // EVENTS
    match /events/{eventId} {
      allow read: if resource.data.published == true || isAdmin();

      // Full create/update/delete restricted to admins
      allow create, update, delete: if isAdmin();

      allow update: if changedOnly(['currentRegistrations'])
        // Allow increment when currentRegistrations was previously missing/null
        // (treat as 0) or when it's explicitly incremented by +1.
        && (
          (resource.data.currentRegistrations == null && request.resource.data.currentRegistrations == 1)
          || (request.resource.data.currentRegistrations == resource.data.currentRegistrations + 1)
        )
        && (resource.data.maxCapacity == null || request.resource.data.currentRegistrations <= resource.data.maxCapacity);
    }

    // TEAM MEMBERS
    match /teamMembers/{id} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // BLOG POSTS
    match /blogPosts/{postId} {
      allow read: if resource.data.published == true || isAdmin();
      allow create, update, delete: if isAdmin();
    }

    // JOBS
    match /jobs/{jobId} {
      // Read if published or admin
      allow read: if resource.data.published == true || isAdmin();
      // Only admins can write
      allow create, update, delete: if isAdmin();
    }

    // FAQ
    match /faqs/{faqId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // REGISTRATION QUESTIONS (global)
    match /registrationQuestions/{rqId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // EVENT CUSTOM QUESTIONS (per-event)
    match /eventCustomQuestions/{cqId} {
      // Publicly readable to render forms
      allow read: if true;

      // Only admins may write, with strict schema validation
      allow create: if isAdmin()
        && request.resource.data.keys().hasOnly(['eventId','question','type','options','required','order'])
        && validEventCustomQuestion(request.resource.data);

      allow update: if isAdmin()
        && request.resource.data.keys().hasOnly(['eventId','question','type','options','required','order'])
        && validEventCustomQuestion(request.resource.data)
        // eventId must not change once created
        && request.resource.data.eventId == resource.data.eventId;

      allow delete: if isAdmin();
    }

    // REGISTRATIONS
    match /registrations/{regId} {
      // Only members can create a registration for themselves
      allow create: if isMember()
        // Ensure registration is created for the caller
        && request.resource.data.userId == request.auth.uid
        // Lock certain fields: only these are allowed by client
        && request.resource.data.keys().hasOnly(
             ['eventId', 'registrationData', 'registeredAt', 'status', 'userEmail', 'userName', 'userId']
           )
        // Restrict status to registered|waitlist
        && (request.resource.data.status in ['registered', 'waitlist'])
        // registeredAt must be a timestamp. When clients use serverTimestamp
        // transforms the field can appear as null in the request, so allow
        // either a timestamp or null here.
        && (
          (request.resource.data.registeredAt is timestamp) ||
          (request.resource.data.registeredAt == null)
        );

      // Users can read their own registrations; admins can read all
      allow read: if isAdmin() || (isSignedIn() && resource.data.userId == request.auth.uid);

      // Only admins may delete registrations by default
      allow delete: if isAdmin();

      // Allow a user to delete their own registration if it has already been cancelled.
      // This supports a clean re-register flow by removing stale cancelled docs.
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource.data.status == 'cancelled';

      // Admin full update
      allow update: if isAdmin();

      // Allow a signed-in user to cancel their own registration by setting status -> 'cancelled'
      // Constraints:
      // - Only the owner (userId == auth.uid)
      // - Only allowed field change: status
      // - New status must be exactly 'cancelled'
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid
        && changedOnly(['status'])
        && request.resource.data.status == 'cancelled';

      // Exception: allow invited -> confirmed transition for token-based confirmation on the public confirmation page.
      // Constraints:
      // - Only fields changed: status, confirmedAt, confirmationToken
      // - Existing status must be 'invited'
      // - New status must be 'confirmed'
      // - Existing confirmationToken must be non-null
      // - New confirmationToken must be null
      allow update: if
        changedOnly(['status','confirmedAt','confirmationToken']) &&
        resource.data.status == 'invited' &&
        request.resource.data.status == 'confirmed' &&
        resource.data.confirmationToken != null &&
        request.resource.data.confirmationToken == null;
    }

    // ANALYTICS (client-side dedup with localStorage; guarded increments)
    // Events: unique clicks (increment-only)
    match /analyticsEvents/{eventId} {
      // Admin can read analytics; you can open reads if you want
      allow read: if isAdmin();

      // Create initial doc with clicks:1
      allow create: if request.resource.data.keys().hasOnly(['clicks', 'updatedAt'])
        && request.resource.data.clicks == 1;

      // Update: only clicks (+1) and updatedAt allowed
      allow update: if changedOnly(['clicks', 'updatedAt'])
        && request.resource.data.clicks == resource.data.clicks + 1;

      // No deletes from clients
      allow delete: if isAdmin();
    }

    // Blogs: unique reads (increment-only)
    match /analyticsBlogs/{blogId} {
      allow read: if isAdmin();

      allow create: if request.resource.data.keys().hasOnly(['reads', 'updatedAt'])
        && request.resource.data.reads == 1;
      allow update: if changedOnly(['reads', 'updatedAt'])
        && request.resource.data.reads == resource.data.reads + 1;

      allow delete: if isAdmin();
    }

    // MAIL QUEUE for Firebase Trigger Email extension
    match /mail/{messageId} {
      // Only admins can enqueue outgoing emails from the client
      allow create: if isAdmin();
      // Optional: allow admins to read messages for debugging
      allow read: if isAdmin();
      // No client updates or deletes
      allow update, delete: if false;
    }
  }
}